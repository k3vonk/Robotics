#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int const DEFAULT_SPEED = 15;
int const TURN_SPEED = 5;
int const GYRO_TURN = 82;

int const MIN_DISTANCE = 7;
int const SEARCH_DISTANCE = 25;

int const RED = 5;

/*
 *Robot stops all its actions
 */
void pause(){
	//Stops everything so robot can do its next action
	stopAllMotors();
	sleep(500);  			//Stops for 0.5 seconds
}

/*
 *Checks if an object or debris is in front
 *
 *@return true - no objects in front, false - object is between robot and distance
 */
bool isClear(int distance){

	pause();
	if(SensorValue(sonarSensor) < distance){
		return false;
	}else{
		return true;
	}
}

/*
 *Moves the robot close to something it sees
 */
void moveTo(int distance){
	while(SensorValue(sonarSensor) > distance){
		//motor[motorB] = DEFAULT_SPEED;
		//motor[motorC] = DEFAULT_SPEED;
		forward(0.1, rotations, DEFAULT_SPEED);
	}
}

/*
 *Moves the robot back from something it sees
 */
void moveBack(int distance){
	while(SensorValue(sonarSensor) < distance){
		//motor[motorB] = -DEFAULT_SPEED;
		//motor[motorC] = -DEFAULT_SPEED;
		backward(0.1, rotations, DEFAULT_SPEED);
	}
}

/*
 *Checks to see distance between object and robot.
 *Moves accordingly
 *Drops arm, move to object, picks it up, raises arm
 */
void pickUp(){
	if(SensorValue(sonarSensor) < 12){ //If object is close to robot
		moveBack(10);
		pause();
	}else{ //If object is far from robot
		moveTo(10);
		pause();
	}
	//Drop arm
	motor[motorA] = -DEFAULT_SPEED;
	wait1Msec(750);

	//Move to collect
	pause();
	moveTo(4);
	forward(0.1, rotations, DEFAULT_SPEED);
	pause();

	//raise arms
	motor[motorA] = DEFAULT_SPEED;
	wait1Msec(750);
	pause();
}

/*
 *Calculates the distance from the wall and returns the number of ticks
 */
float tickDistance(){
	float distance;							//Gary now needs to read the distance he is, when at the edge of the fire, from the wall.
	float ticks;							//FORMULA: Encoder ticks = (360/circumference)*(Distance to travel-allowance for Gary's body)
	distance = 	getUSDistance(sonarSensor);	//Gary is now going to use an formula to find out how far he needs to reverse over the fire.
	ticks = (20.34*(distance-8));		    //This is the value we will use for the motor encoders for when Gary is reversing.
	return ticks;
}

/*
 *The robot reverses back at a set speed, at a given distance
 */
void reverseDistance(float number)
{
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	while(nMotorEncoder[motorB] > -number && nMotorEncoder[motorC] > -number)	{
		//motor(motorB) = -DEFAULT_SPEED;
		//motor(motorC) = -DEFAULT_SPEED;
		backward(0.1, rotations, DEFAULT_SPEED);
	}
}

/*
 *Gary moves forward until it touches something
 */
void moveTillTouch()
{
	while(SensorValue(touchSensor) == 0){
		//motor[motorB] = DEFAULT_SPEED;
		//motor[motorC] = DEFAULT_SPEED;
		forward(0.1, rotations, DEFAULT_SPEED);
	}
}

/*
 *Allows the robot to turn at an angle
*/
void gyroTurn(char *direction, int angle){

	resetGyro(gyroSensor);

	//Turn left
	if(strcmp("left",direction) == 0){
		setMotorSpeed(motorB, -TURN_SPEED);
		setMotorSpeed(motorC, TURN_SPEED);
		waitUntil(SensorValue[gyroSensor] < -angle);
		//Turn right
	}else if(strcmp("right", direction) == 0){
		setMotorSpeed(motorB, TURN_SPEED);
		setMotorSpeed(motorC, -TURN_SPEED);
		waitUntil(SensorValue[gyroSensor] > angle);
	}
	//Stops the motors
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
}

void redRoom(){
		int redTick = tickDistance();

			//Needs changes
		gyroTurn("right", GYRO_TURN*2);
		reverseDistance(redTick);
		gyroTurn("left", GYRO_TURN);
		moveBack(30);
		gyroTurn("left", 165);
		forward(1.4, rotations, DEFAULT_SPEED);

}

void touchRoom(){
		//Needs changes
		moveBack(MIN_DISTANCE);
		gyroTurn("right", GYRO_TURN);
		moveBack(40);
		gyroTurn("left", GYRO_TURN);
		moveTo(MIN_DISTANCE);
		gyroTurn("left", GYRO_TURN);
		forward(1, rotations,DEFAULT_SPEED);
}

task main(){
	for(int room = 0; room < 4; room++){
		for(int pos = 0; pos < 3; pos++){
			if(pos == 0){
				//Clear - walk 25cm
				if(isClear(SEARCH_DISTANCE)){
					forward(1.5, rotations, DEFAULT_SPEED);
					pause();
				}else{ //object in front
					//Move to object, pick up, move to wall exit;
					pickUp();
					moveTo(MIN_DISTANCE);
					gyroTurn("left", GYRO_TURN);

					forward(2.5,rotations,DEFAULT_SPEED);
					break;
				}

				//Second check
				if(isClear(SEARCH_DISTANCE)){

					while((SensorValue(sonarSensor) > MIN_DISTANCE) && (SensorValue(colorSensor) != RED)){
					/*	motor[motorB] = DEFAULT_SPEED;
						motor[motorC] = DEFAULT_SPEED; */
						forward(0.1,rotations, DEFAULT_SPEED);
					}

					//If red room
					pause();
					if(SensorValue(colorSensor) == RED){
							redRoom();
							break;
					}else{ //Not red room
						gyroTurn("left", GYRO_TURN);
					}
				}else{ //Debris or object
					moveTo(MIN_DISTANCE);
					pause();
					forward(650, milliseconds, DEFAULT_SPEED);
					pause();

					//Touch room
					if(SensorValue(touchSensor) == 1){
						touchRoom();
						break;
					}else{
						//Move to object, pick up, move to wall exit;
						pickUp();
						moveTo(MIN_DISTANCE);
						gyroTurn("left", GYRO_TURN);

						forward(2.5,rotations,DEFAULT_SPEED);
						break;
					}
				}

			}else{
				if(isClear(SEARCH_DISTANCE)){
					forward(0.65, rotations, DEFAULT_SPEED);
					gyroTurn("left", GYRO_TURN);
				}else{
					pickUp();
					forward(3 - (pos*1), rotations, DEFAULT_SPEED);
					break;
				}

				//SEARCH ROW
				if(isClear(SEARCH_DISTANCE)){
					gyroTurn("right", GYRO_TURN);

					if(pos == 2){
						forward(3 - (pos*1), rotations, DEFAULT_SPEED);
						setSoundVolume(50);
						playTone(100, 100);
					}
				}
				else{ //There is an object

					//move to object, pick up, reverse, turn right, go to exit
					int tick = tickDistance();
					pause();
					pickUp();
					reverseDistance(tick);
					gyroTurn("right", GYRO_TURN);
					forward(3 - (pos*1), rotations, DEFAULT_SPEED);
					break;
				}
			}
		}
	}
}
